//---------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 예약행동을 지원하는 MonoBehaviour 파생클래스
/// </summary>
public class K_ReadyToWork : MonoBehaviour
{
    public delegate IEnumerator CoroutineWork(MonoBehaviour mono);
    Queue<CoroutineWork> orders = new Queue<CoroutineWork>();
    public bool Working { private set; get; }

    public K_ReadyToWork AddOrder(CoroutineWork order)
    {
        orders.Enqueue(order);
        return this;
    }

    IEnumerator tempWork(Action action) {
        action();
        yield break;
    }

    public K_ReadyToWork AddOrder(Action order)
    {
        orders.Enqueue(x => tempWork(order));
        return this;
    }
    
    public void GoWork()
    {
        if (!Working)
            StartCoroutine(WorkDo());
    }

    public void ImmediatelyStop()
    {
        StopCoroutine("WorkDo");
        orders.Clear();
        Working = false;
    }

    IEnumerator WorkDo()
    {
        Working = true;
        while (orders.Count > 0)
        {
            yield return StartCoroutine((orders.Dequeue())(this));
        }
        Working = false;
    }

    protected IEnumerator Delay(float duration){
        yield return new WaitForSeconds(duration);
    }

    protected IEnumerator MoveTo(Vector3 from, Vector3 to, K_TimeCurve timecurve)
    {
        do
        {
            timecurve.Progress();
            transform.position = Vector3.Lerp(from, to, timecurve.Eval);
            yield return null;
        } while (timecurve.Eval != 1f);
    }

    protected IEnumerator Loop(Action loop, Func<bool> flag)
    {
        do
        {
            loop();
            yield return null;
        } while (flag());        
    }

    public K_ReadyToWork AddDelay(float duration){
        AddOrder(x => Delay(duration));
        return this;
    }

    public K_ReadyToWork AddPosition(Vector3 to){
        AddOrder(() => transform.position = to);
        return this;
    }

    public K_ReadyToWork AddPosition(Vector3 to, float speed, NormalCurve.Ease curve){
        Func<Vector3> position = () => transform.position;
        Vector3 from = transform.position;
        AddOrder(() => from = position());

        K_TimeCurve timecurve = K_TimeCurve.Ease(curve, Vector3.Distance(from, to) / speed);
        AddOrder(x => MoveTo(from, to, timecurve));

        return this;
    }

    public K_ReadyToWork AddPosition(Vector3 to, K_TimeCurve timecurve)
    {
        Func<Vector3> position = () => transform.position;
        Vector3 from = transform.position;
        AddOrder(() => from = position());
        AddOrder(x => MoveTo(from, to, timecurve));
        return this;
    }

    public K_ReadyToWork AddPath(Vector3[] path, K_TimeCurve[] duration)
    {
        if (path.Length != duration.Length)
            throw new Exception();

        for (int i = 0; i < path.Length; i++)
        {
            AddPosition(path[i], duration[i]);
        }

        return this;
    }
}